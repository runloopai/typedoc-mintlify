name: Semantic Pull Request

on:
  pull_request:
    types: [opened, edited, reopened, synchronize]

jobs:
  validate:
    name: Validate PR Title
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR Title
        uses: amannn/action-semantic-pull-request@48f256284bd46cdaab1048c3721360e808335d50
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # Allow WIP PRs
          wip: true
          # Custom types if needed (defaults to conventional commits)
          types: |
            feat
            fix
            docs
            style
            refactor
            perf
            test
            build
            ci
            chore
            revert

  suggest-commit:
    name: Suggest Squash Commit Message
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: runloopai/checkout@main
        with:
          fetch-depth: 0

      - name: Generate suggested squash commit message
        id: suggest
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          # Get all commits in the PR, excluding merge commits
          COMMITS=$(git log origin/${{ github.base_ref }}..HEAD --pretty=format:"%s" --no-merges)
          
          # Filter out merge-related commits and duplicates
          CLEAN_COMMITS=$(echo "$COMMITS" | \
            grep -vE "^Merge |^merge |^Merged |^merged " | \
            grep -vE "^[0-9a-f]{8,} " | \
            sort -u)
          
          # Count commit types from clean commits
          FEAT_COUNT=$(echo "$CLEAN_COMMITS" | grep -cE "^feat" || true)
          FIX_COUNT=$(echo "$CLEAN_COMMITS" | grep -cE "^fix" || true)
          DOCS_COUNT=$(echo "$CLEAN_COMMITS" | grep -cE "^docs" || true)
          
          # Determine primary type (feat > fix > docs)
          if [ "$FEAT_COUNT" -gt 0 ]; then
            TYPE="feat"
          elif [ "$FIX_COUNT" -gt 0 ]; then
            TYPE="fix"
          elif [ "$DOCS_COUNT" -gt 0 ]; then
            TYPE="docs"
          else
            TYPE="chore"
          fi
          
          # Extract scopes from clean commits (only conventional commits)
          SCOPES=$(echo "$CLEAN_COMMITS" | \
            grep -E "^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)\([^)]+\):" | \
            grep -oE "\(([^)]+)\)" | \
            sed 's/[()]//g' | \
            sort -u | \
            tr '\n' ',' | \
            sed 's/,$//' | \
            sed 's/,/, /g')
          
          # Create suggested message header
          if [ -n "$SCOPES" ]; then
            SUGGESTED_HEADER="$TYPE($SCOPES): "
          else
            SUGGESTED_HEADER="$TYPE: "
          fi
          
          # Use PR title if it follows conventional commits, otherwise build from commits
          if echo "$PR_TITLE" | grep -qE "^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?:"; then
            # PR title already has type, use it as-is
            FULL_MESSAGE="$PR_TITLE"
          elif [ -n "$PR_TITLE" ]; then
            # PR title exists but no type, add our determined type and scope
            FULL_MESSAGE="${SUGGESTED_HEADER}${PR_TITLE}"
          else
            # No PR title, use first conventional commit description
            FIRST_CONV_COMMIT=$(echo "$CLEAN_COMMITS" | grep -E "^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)" | head -1)
            if [ -n "$FIRST_CONV_COMMIT" ]; then
              FIRST_DESC=$(echo "$FIRST_CONV_COMMIT" | sed 's/^[^:]*: //')
              FULL_MESSAGE="${SUGGESTED_HEADER}${FIRST_DESC}"
            else
              # Fallback to first commit
              FIRST_DESC=$(echo "$CLEAN_COMMITS" | head -1)
              FULL_MESSAGE="${SUGGESTED_HEADER}${FIRST_DESC}"
            fi
          fi
          
          # Add body with commit details (preserve type and scope for each commit)
          BODY=""
          SEEN_COMMITS=""
          while IFS= read -r commit; do
            if [ -z "$commit" ]; then
              continue
            fi
            
            # Skip merge commits
            if echo "$commit" | grep -qE "^Merge |^merge "; then
              continue
            fi
            
            # Skip if we've seen this exact commit message before
            if echo "$SEEN_COMMITS" | grep -qFx "$commit"; then
              continue
            fi
            
            # Add to seen list
            SEEN_COMMITS="${SEEN_COMMITS}${commit}\n"
            
            # Check if it's a conventional commit
            if echo "$commit" | grep -qE "^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([^)]+\))?:"; then
              # Preserve the full commit format (type(scope): description)
              BODY="${BODY}- ${commit}\n"
            else
              # Non-conventional commit, just add description
              BODY="${BODY}- ${commit}\n"
            fi
          done <<< "$CLEAN_COMMITS"
          
          # Limit to first 10 unique commits
          BODY=$(echo -e "$BODY" | head -10)
          
          # Append body if we have commits
          if [ -n "$BODY" ]; then
            FULL_MESSAGE="${FULL_MESSAGE}\n\n${BODY}"
          fi
          
          # Output for GitHub Actions (multiline)
          {
            echo "message<<EOF"
            echo -e "$FULL_MESSAGE"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Comment on PR with suggested message
        uses: runloopai/github-script@main
        if: github.event.action != 'synchronize'
        env:
          SUGGESTED_MESSAGE: ${{ steps.suggest.outputs.message }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const message = process.env.SUGGESTED_MESSAGE || 'Unable to generate message';
            
            const comment = `## ðŸ’¡ Suggested Squash Commit Message
            
            When you merge this PR with squash, use this commit message:
            
            \`\`\`
            ${message}
            \`\`\`
            
            **Note:** GitHub will use your PR title as the default squash commit message. Make sure your PR title follows Conventional Commits format:
            - \`feat(scope): description\`
            - \`fix(scope): description\`
            - \`docs(scope): description\`
            
            **Tip:** Configure GitHub to use PR title as default squash commit message in Settings â†’ Pull Requests.`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

